<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vuex</title>
      <link href="/2020/07/30/Vuex/"/>
      <url>/2020/07/30/Vuex/</url>
      
        <content type="html"><![CDATA[<p>Vuex 应用的核心就是 store</p><p>Vuex 和单纯的全局对象有以下两点不同：<br>1Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。<br>2你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</p><p>通过 store.state 来获取状态对象，以及通过 store.commit 方法触发状态变更<br>通过提交 mutation 的方式，而非直接改变 store.state.count，是因为我们想要更明确地追踪到状态的变化。</p><h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><p>Vuex 使用单一状态树</p><p>vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态：</p><p>这种模式导致组件依赖全局状态单例。在模块化的构建系统中，在每个需要使用 state 的组件中需要频繁地导入，并且在测试组件时需要模拟状态。</p><p>Vuex 通过 store 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 Vue.use(Vuex)）<br>通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且<strong>子组件能通过 this.$store 访问到</strong>。</p><h3 id="mapState"><a href="#mapState" class="headerlink" title="mapState"></a>mapState</h3><p>当一个组件需要获取多个状态的时候</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在单独构建的版本中辅助函数为 Vuex.mapState</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  computed: mapState(&#123;</span><br><span class="line">    <span class="comment">// 箭头函数可使代码更简练</span></span><br><span class="line">    count: <span class="function"><span class="params">state</span> =&gt;</span> state.count,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传字符串参数 'count' 等同于 `state =&gt; state.count`</span></span><br><span class="line">    countAlias: <span class="string">'count'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了能够使用 `this` 获取局部状态，必须使用常规函数</span></span><br><span class="line">    countPlusLocalState (state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count + <span class="keyword">this</span>.localCount</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。</span></span><br><span class="line">computed: mapState([</span><br><span class="line">  <span class="comment">// 映射 this.count 为 store.state.count</span></span><br><span class="line">  <span class="string">'count'</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure><h3 id="对象展开运算符"><a href="#对象展开运算符" class="headerlink" title="对象展开运算符"></a>对象展开运算符</h3><p>工具函数将多个对象合并为一个</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; mapState, mapGetters &#125; <span class="keyword">from</span> <span class="string">"vuex"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">"increment"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  computed: &#123;</span><br><span class="line">    ...mapGetters([<span class="string">"count"</span>]),</span><br><span class="line"></span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">      counts() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h2><p>可以认为是 store 的计算属性，<br>getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    doneTodos: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done)</span><br><span class="line">    &#125;,</span><br><span class="line"> <span class="comment">// 也可以接受其他 getter 作为第二个参数</span></span><br><span class="line"> doneTodosCount: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getters.doneTodos.length</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 通过让 getter 返回一个函数，来实现给 getter 传参</span></span><br><span class="line">   getTodoById: <span class="function">(<span class="params">state</span>) =&gt;</span> <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.todos.find(<span class="function"><span class="params">todo</span> =&gt;</span> todo.id === id)</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.getters.doneTodos <span class="comment">// -&gt; [&#123; id: 1, text: '...', done: true &#125;]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意 getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果</span></span><br><span class="line">store.getters.getTodoById(<span class="number">2</span>) <span class="comment">// -&gt; &#123; id: 2, text: '...', done: false &#125;</span></span><br></pre></td></tr></table></figure><p>组件中使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  doneTodosCount () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.doneTodosCount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mapGetters-辅助函数"><a href="#mapGetters-辅助函数" class="headerlink" title="mapGetters 辅助函数"></a>mapGetters 辅助函数</h3><p>mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  computed: &#123;</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将 getter 混入 computed 对象中</span></span><br><span class="line">    ...mapGetters([</span><br><span class="line">      <span class="string">'doneTodosCount'</span>,</span><br><span class="line">      <span class="string">'anotherGetter'</span>,</span><br><span class="line">      <span class="comment">// 另取名字</span></span><br><span class="line">      doneCount: <span class="string">'doneTodosCount'</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h2><p><strong>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。</strong><br>每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      <span class="comment">// 变更状态</span></span><br><span class="line">      state.count++</span><br><span class="line">    &#125;，</span><br><span class="line">    <span class="comment">// 可以向store.commit 传入额外的参数</span></span><br><span class="line">    <span class="comment">// 在大多数情况下，载荷应该是一个对象</span></span><br><span class="line">  otherIncrement (state, payload) &#123;</span><br><span class="line">     state.count += payload.amount</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要以相应的 type 调用 store.commit 方法聊调用mutations函数</span></span><br><span class="line">store.commit(<span class="string">'increment'</span>)</span><br><span class="line"><span class="comment">// 多传参学名叫载荷（payload）</span></span><br><span class="line">store.commit(<span class="string">'otherIncrement'</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// 对象风格提交</span></span><br><span class="line">store.commit(&#123;</span><br><span class="line">  type: <span class="string">'increment'</span>,</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Mutation-需遵守-Vue-的响应规则"><a href="#Mutation-需遵守-Vue-的响应规则" class="headerlink" title="Mutation 需遵守 Vue 的响应规则"></a>Mutation 需遵守 Vue 的响应规则</h3><p>当我们变更状态时，监视状态的 Vue 组件也会自动更新。注意事项：</p><ol><li><p>最好提前在你的 store 中初始化好所有所需属性。</p></li><li><p>当需要在对象上添加新属性时</p></li></ol><ul><li>使用 Vue.set(obj, ‘newProp’, 123), 或者</li><li>以新对象替换老对象。例如，利用对象展开运算符我们可以这样写：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">state.obj = &#123; ...state.obj, <span class="attr">newProp</span>: <span class="number">123</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="使用常量替代-Mutation-事件类型"><a href="#使用常量替代-Mutation-事件类型" class="headerlink" title="使用常量替代 Mutation 事件类型"></a>使用常量替代 Mutation 事件类型</h3><h3 id="Mutation-必须是同步函数"><a href="#Mutation-必须是同步函数" class="headerlink" title="Mutation 必须是同步函数"></a>Mutation 必须是同步函数</h3><p>每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。异步函数中的回调让这不可能完成,任何在回调函数中进行的状态的改变都是不可追踪的。</p><h3 id="mapMutations"><a href="#mapMutations" class="headerlink" title="mapMutations"></a>mapMutations</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapMutations([</span><br><span class="line">      <span class="string">'increment'</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.commit('increment')`</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// `mapMutations` 也支持载荷：</span></span><br><span class="line">      <span class="string">'incrementBy'</span> <span class="comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`</span></span><br><span class="line">    ]),</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">      add: <span class="string">'increment'</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.commit('increment')`</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><table><thead><tr><th align="left">调用</th><th align="left">方法</th><th align="left">辅助函数</th></tr></thead><tbody><tr><td align="left">state</td><td align="left">this.$store.state. xxx</td><td align="left">mapState</td></tr><tr><td align="left">getters</td><td align="left">this.$store.getters. xxx</td><td align="left">mapGetters</td></tr><tr><td align="left">mutations</td><td align="left">this.$store.cmmit(（xxx）</td><td align="left">mapMutations</td></tr><tr><td align="left">actions</td><td align="left">this.$store.dispatch（xxx ）</td><td align="left">mapActions</td></tr></tbody></table><p><strong>mapState和mapGetter的使用只能在computed计算属性中， mapMutations和mapActions使用的时候只能在methods中调用否则报错</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState , mapMutations , mapActions , mapGetters  &#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed:&#123;</span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">      counts:<span class="function">(<span class="params">state</span>) =&gt;</span> state.count</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">//mapState就等于下面这个</span></span><br><span class="line">    <span class="comment">// counts()&#123;</span></span><br><span class="line">    <span class="comment">//   return this.$store.state.count</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">    ...mapGetters(&#123;</span><br><span class="line">      getternum:<span class="string">'doneTodos'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">//mapGetters就等于下面的这个</span></span><br><span class="line">    <span class="comment">// getternum()&#123;</span></span><br><span class="line">    <span class="comment">//   return this.$store.getters.doneTodos</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">      addnum:<span class="string">'addNum'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    addnum1()&#123;</span><br><span class="line">      <span class="keyword">this</span>.addnum()</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//mapMutations就等于下面的这个</span></span><br><span class="line">    <span class="comment">// addnum1()&#123;</span></span><br><span class="line">    <span class="comment">//   this.$store.commit('addNum')</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line"></span><br><span class="line">    ...mapActions(&#123;</span><br><span class="line">      actionnum:<span class="string">'actionNumAdd'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    actionnum6()&#123;</span><br><span class="line">      <span class="keyword">this</span>.actionnum()</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//mapActions就等于下面的这个</span></span><br><span class="line">    <span class="comment">//  actionnum6()&#123;</span></span><br><span class="line">    <span class="comment">//   this.$store.dispatch('actionNumAdd')</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><ul><li>Action 提交的是 mutation, 而不是直接变更状态。</li><li>Action 可以包含任意异步操作。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">   <span class="comment">// 与 store 实例具有相同方法和属性的 context 对象</span></span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.commit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ES2015</span></span><br><span class="line">    increment (&#123; commit &#125;) &#123;</span><br><span class="line">    commit(<span class="string">'increment'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="分发Action"><a href="#分发Action" class="headerlink" title="分发Action"></a>分发Action</h3><p>通过 store.dispatch 方法触发：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.dispatch(<span class="string">'increment'</span>)</span><br></pre></td></tr></table></figure><p>购物车示例，涉及到调用异步 API 和分发多重 mutation：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  checkout (&#123; commit, state &#125;, products) &#123;</span><br><span class="line">    <span class="comment">// 把当前购物车的物品备份起来</span></span><br><span class="line">    <span class="keyword">const</span> savedCartItems = [...state.cart.added]</span><br><span class="line">    <span class="comment">// 发出结账请求，然后乐观地清空购物车</span></span><br><span class="line">    commit(types.CHECKOUT_REQUEST)</span><br><span class="line">    <span class="comment">// 购物 API 接受一个成功回调和一个失败回调</span></span><br><span class="line">    shop.buyProducts(</span><br><span class="line">      products,</span><br><span class="line">      <span class="comment">// 成功操作</span></span><br><span class="line">      () =&gt; commit(types.CHECKOUT_SUCCESS),</span><br><span class="line">      <span class="comment">// 失败操作</span></span><br><span class="line">      () =&gt; commit(types.CHECKOUT_FAILURE, savedCartItems)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在组件中分发-Action"><a href="#在组件中分发-Action" class="headerlink" title="在组件中分发 Action"></a>在组件中分发 Action</h3><p>在组件中使用 this.$store.dispatch(‘xxx’) 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions([</span><br><span class="line">      <span class="string">'increment'</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// `mapActions` 也支持载荷：</span></span><br><span class="line">      <span class="string">'incrementBy'</span> <span class="comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`</span></span><br><span class="line">    ]),</span><br><span class="line">    ...mapActions(&#123;</span><br><span class="line">      add: <span class="string">'increment'</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.dispatch('increment')`</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合Action"><a href="#组合Action" class="headerlink" title="组合Action"></a>组合Action</h3><p>store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        commit(<span class="string">'someMutation'</span>)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">actions: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      commit(<span class="string">'someOtherMutation'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设 getData() 和 getOtherData() 返回的是 Promise</span></span><br><span class="line"></span><br><span class="line">actions: &#123;</span><br><span class="line">  <span class="keyword">async</span> actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    commit(<span class="string">'gotData'</span>, <span class="keyword">await</span> getData())</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">await</span> dispatch(<span class="string">'actionA'</span>) <span class="comment">// 等待 actionA 完成</span></span><br><span class="line">    commit(<span class="string">'gotOtherData'</span>, <span class="keyword">await</span> getOtherData())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: <span class="function"><span class="params">()</span> =&gt;</span> (&#123; ... &#125;),</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  state: <span class="function"><span class="params">()</span> =&gt;</span> (&#123; ... &#125;),</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a <span class="comment">// -&gt; moduleA 的状态</span></span><br><span class="line">store.state.b <span class="comment">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure><p>对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;),</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      <span class="comment">// 这里的 `state` 对象是模块的局部状态</span></span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  getters: &#123;</span><br><span class="line">    doubleCount (state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，对于模块内部的 action，局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  actions: &#123;</span><br><span class="line">    incrementIfOddOnRootSum (&#123; state, commit, rootState &#125;) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((state.count + rootState.count) % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        commit(<span class="string">'increment'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  getters: &#123;</span><br><span class="line">    sumWithRootCount (state, getters, rootState) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count + rootState.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><ol><li><p>应用层级的状态应该集中到单个 store 对象中。</p></li><li><p>提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。</p></li><li><p>异步逻辑都应该封装到 action 里面。</p></li></ol><figure class="highlight"><table><tr><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">├── main.js</span><br><span class="line">├── api</span><br><span class="line">│   └── ... # 抽取出API请求</span><br><span class="line">├── components</span><br><span class="line">│   ├── App.vue</span><br><span class="line">│   └── ...</span><br><span class="line">└── store</span><br><span class="line">    ├── index.js          # 我们组装模块并导出 store 的地方</span><br><span class="line">    ├── actions.js        # 根级别的 action</span><br><span class="line">    ├── mutations.js      # 根级别的 mutation</span><br><span class="line">    └── modules</span><br><span class="line">        ├── cart.js       # 购物车模块</span><br><span class="line">        └── products.js   # 产品模块</span><br></pre></td></tr></table></figure><h3 id="热重载"><a href="#热重载" class="headerlink" title="热重载"></a>热重载</h3>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
          <category> 回忆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue和小程序 使用差异整理</title>
      <link href="/2020/07/30/Vue%E5%92%8C%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
      <url>/2020/07/30/Vue%E5%92%8C%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>Vue <strong>：、@、# 分别是：v-bind:、v-on:、v-slot: 的缩写。</strong></p><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><p>Vue:</p><ul><li><strong>v-if</strong></li><li><strong>v-else</strong></li><li><strong>v-else-if</strong></li></ul><p>小程序:</p><ul><li><strong>wx:if</strong></li><li><strong>wx:else</strong></li><li><strong>wx:elif</strong></li></ul><h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><p>Vue:</p><ul><li><strong>v-for=”item in items”</strong></li><li><strong>v-for=”(item, index) in items,</strong></li><li><strong>v-for=”(value, name, index) in object”</strong></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ul id=<span class="string">"example-1"</span>&gt;</span><br><span class="line">  &lt;li v-<span class="keyword">for</span>=<span class="string">"item in items"</span> :key=<span class="string">"item.message"</span>&gt;</span><br><span class="line">    &#123;&#123; item.message &#125;&#125;</span><br><span class="line">  &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JS</span></span><br><span class="line"><span class="keyword">var</span> example1 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-1'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [</span><br><span class="line">      &#123; <span class="attr">message</span>: <span class="string">'Foo'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">message</span>: <span class="string">'Bar'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>小程序: <strong>wx:for</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;view wx:<span class="keyword">for</span>=<span class="string">"&#123;&#123;array&#125;&#125;"</span> wx:<span class="keyword">for</span>-index=<span class="string">"idx"</span> wx:<span class="keyword">for</span>-item=<span class="string">"itemName"</span>&gt;</span><br><span class="line">  &#123;&#123;idx&#125;&#125;: &#123;&#123;itemName.message&#125;&#125;</span><br><span class="line">&lt;<span class="regexp">/view&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ js</span></span><br><span class="line"><span class="regexp">Page(&#123;</span></span><br><span class="line"><span class="regexp">  data: &#123;</span></span><br><span class="line"><span class="regexp">    array: [&#123;</span></span><br><span class="line"><span class="regexp">      message: 'foo',</span></span><br><span class="line"><span class="regexp">    &#125;, &#123;</span></span><br><span class="line"><span class="regexp">      message: 'bar'</span></span><br><span class="line"><span class="regexp">    &#125;]</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure><h3 id="显示隐藏"><a href="#显示隐藏" class="headerlink" title="显示隐藏"></a>显示隐藏</h3><p>Vue: <strong>v-show=”“</strong><br>小程序: <strong>hidden=”“</strong></p><h3 id="绑定-class"><a href="#绑定-class" class="headerlink" title="绑定 class"></a>绑定 class</h3><p>Vue: <strong>v-bind 或:bind</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"test"</span> v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"&#123; select: isSelect &#125;"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p>小程序: <strong>拼接字符串</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;view <span class="class"><span class="keyword">class</span></span>=<span class="string">"test &#123;&#123;isSelect ? 'select':'' &#125;&#125;"</span>&gt;&lt;<span class="regexp">/view&gt;</span></span><br></pre></td></tr></table></figure><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>Vue: <strong>v-on:event 或@event</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button v-on:click=<span class="string">"count += 1"</span>&gt;Add &lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><p>小程序: <strong>bindtap(bind+event), catchtap(catch+event)</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button bindtap=<span class="string">"addMethod"</span>&gt;Add&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><h3 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h3><p>Vue: <strong>this.xxx</strong><br>小程序: <strong>this.data.xxx</strong></p><h3 id="绑定值"><a href="#绑定值" class="headerlink" title="绑定值"></a>绑定值</h3><p>Vue: <strong>动态绑定变量为某个属性时，会在变量前加个:</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img :src=<span class="string">"imgSrc"</span>/&gt;</span><br></pre></td></tr></table></figure><p>小程序: <strong>使用</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;image src=<span class="string">"&#123;&#123;imgSrc&#125;&#125;"</span>&gt;&lt;<span class="regexp">/image&gt;</span></span><br></pre></td></tr></table></figure><h3 id="绑定事件传参"><a href="#绑定事件传参" class="headerlink" title="绑定事件传参"></a>绑定事件传参</h3><p>Vue: <strong>函数括号中传参</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div @click=<span class="string">"changeText(111)"</span>&gt;<span class="number">123</span>&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p>小程序: <strong>绑定到元素，在函数里获取</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;view data-text=<span class="string">"111"</span> catchtap=<span class="string">"changeText"</span>&gt;<span class="number">123</span>&lt;<span class="regexp">/view&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ js</span></span><br><span class="line"><span class="regexp">changeText(e)&#123;</span></span><br><span class="line"><span class="regexp">   let str = e.currentTarget.dataset.text;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="数据双向绑定"><a href="#数据双向绑定" class="headerlink" title="数据双向绑定"></a>数据双向绑定</h3><p>Vue: <strong>v-model</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">"reason"</span> placeholder=<span class="string">"填写理由"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">'reason'</span>/&gt;</span><br></pre></td></tr></table></figure><p>小程序: <strong>通过方法 setData</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input bindinput=<span class="string">"bindReason"</span> placeholder=<span class="string">"填写理由"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">'reason'</span> value=<span class="string">'&#123;&#123;reason&#125;&#125;'</span> name=<span class="string">"reason"</span> /&gt;</span><br><span class="line"></span><br><span class="line">bindReason(e) &#123;</span><br><span class="line">  <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">  reason: e.detail.value</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="父子组件"><a href="#父子组件" class="headerlink" title="父子组件"></a>父子组件</h2><h3 id="子组件"><a href="#子组件" class="headerlink" title="子组件"></a>子组件</h3><p>Vue:</p><ol><li>编写子组件</li><li>父组件中通过 import 引入子组件</li><li>在父组件 components 中注册</li><li>使用</li></ol><p>小程序:</p><ol><li>编写子组件</li><li>在子组件的 json 文件里 声明为组件</li><li>在父组件的 json 文件里 在 usingComponents 填写引入组件的组件名以及路径</li><li>使用</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子组件</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"component"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 父组件</span></span><br><span class="line"> <span class="string">"usingComponents"</span>: &#123;</span><br><span class="line">  <span class="string">"tab-bar"</span>: <span class="string">"../../components/tabBar/tabBar"</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h3><p>Vue:</p><ul><li><strong>父向子传值 在子组件通过 v-bind 传入一个值，在子组件通过 props 接收</strong></li><li><strong>子向父传值 通过 this.$emit 将方法和数据传递给父组件 父组件调用子组件的地方@子组件传的方法=“父组件方法($event) 谁派发谁监听</strong></li><li><strong>父调用子组件方法 给子组件添加 ref=”xxx”属性 通过 this.$refs.xxx.方法 或者 this.$children[0].方法 children 包含自定义组件不保证顺序 也不是响应式</strong></li><li>兄弟组件 <strong>this.$parent.$emit(‘func’), this.$parent.$on(‘func’) 注意 自己本身也能收到$on</strong></li><li>祖孙组件 <strong>祖 provider() {} 子 inject:[‘’] 尽量不用 只能祖先给子孙传 适用组件库的开发</strong></li></ul><p>小程序:</p><ul><li><strong>父向子传值 wxml 上将值赋值给一个变量 子组件用 properties 接收</strong></li><li><strong>子向父传值 子组件使用 this.triggerEvent(‘myevent’, params) 父组件 wxml 组件里 bind:myevent=”fromSon” 然后在 fromSon 方法中获取参数 e.detail</strong></li><li><strong>父调用子的方法 给子组件添加 id 或者 class 通过 this.selectComponent(‘#id’).方法</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
          <category> 回忆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> mini programs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>遇事不决，可问春风</title>
      <link href="/2020/02/24/%E9%81%87%E4%BA%8B%E4%B8%8D%E5%86%B3%EF%BC%8C%E5%8F%AF%E9%97%AE%E6%98%A5%E9%A3%8E/"/>
      <url>/2020/02/24/%E9%81%87%E4%BA%8B%E4%B8%8D%E5%86%B3%EF%BC%8C%E5%8F%AF%E9%97%AE%E6%98%A5%E9%A3%8E/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Rayzworld/Figurebed/topBg/20200727192309.png" alt="TODD"></p><p>从iOS到小程序，到node中台，到前端，到移动端混合，磕磕绊绊做了6年开发了。</p><p>15年的时候搭建了博客，写了小半年但是没有坚持住，现在感觉到，随着技术栈语言的切换，框架库使用的增多，很多当时学会感觉欣喜的小技巧，随着技术栈的切换, 时间线的拉长，会被模糊、遗忘，对个人而言是个很大损失。</p><p>为避免发生语法混淆、实践优化模糊的尴尬，决定继续用博客记录，坚持技术积累，方便自己回忆。</p><p>也希望对你有帮助。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
